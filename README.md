# README

## Running the application:

- run `bundle install`
- run `rails db:create`
- run `rails db:migrate`
- run `rails db:seed` (To populate the 2023 pay periods and job group data)
- run `rails s`

## Tests

- Test endpoints in postman
- run `bundle exec rspec spec`

## Persistence Structure (without autogenerated fields):

- Time_report

  - report_id: unique identifier for each file
  - employee_id(FK): to identify users before storing timesheet data (enables future enhancement for pulling all timesheets for a specific employee)
  - hours_worked: to store time worked in a period for each employee
  - job_group(FK): to store the employee's Job category
  - pay_period(FK): early optimization to store pay period for hours worked
  - Date: to store the date on which the employee worked

- Employee

  - employee_id: to uniquely store users in the system
  - job_group_id(FK): to store the employee's Job category

- Pay_periods

  - start_date: the start of a pay period
  - end_date: the end of a pay period

- Job_group

  - category: to store the job class, i.e., "A/B."
  - wage: to store the job pay i.e., "20"

## Requirements:

[ x ] Uploading a time report

```
Endpoint: http://localhost:3000/time_reports [POST]
payload:{
  "file_path": /path/to/file-id.csv
}

Successful Response: { "message": "File submitted successfully"}
Duplicate file upload error response  : {error: "File has been processed before"}
Missing Parameter error response  : {error: "File not included"}
```

[ x ] Retrieving a payroll report

```
Endpoint: http://localhost:3000/employee_reports [GET]

*Sample* Response: {
  "payrollReport": {
    "employeeReports": [{
      "employeeId": 1,
      "payPeriod": {
        "startDate": "2023-11-01",
        "endDate": "2023-11-15"
      },
      "amountPaid": "$140.00."
    }, {
      "employeeId": 1,
      "payPeriod": {
        "startDate": "2023-11-16",
        "endDate": "2023-11-30"
      },
      "amount paid": "$220.00."
    }, {
      "employeeId": 3,
      "payPeriod": {
        "startDate": "2023-12-01",
        "endDate": "2023-12-15"
      },
      "amountPaid": "$460.00."
    },  {
      "employeeId": 4,
      "payPeriod": {
        "startDate": "2023-12-01",
        "endDate": "2023-12-15"
      },
      "amountPaid": "$150.00."
    }, {
      "employeeId": 4,
      "payPeriod": {
        "startDate": "2023-12-16",
        "endDate": "2023-12-31"
      },
      "amountPaid": "$450.00."
    }]
  }
}
Successful : 200 OK
Unsuccessful response: { error: 'Failed to generate report' }
```

## Improvements to make this app production ready

- File storage and archival - Cloud storage

  Ideally, we should save raw files to S3 for a more robust, secure, and cost-effective solution for storing and managing data at scale. We want to keep customer provided file-data even after it has been processed.

- Improve security around the payroll API.

  No security features were implemented due to time constraints, but ideally, we should restrict access to privileged employee data, and only those with the correct permissions should be able to generate a payroll report.

- Ensure that report generation is better tracked, idempotent, and scalable:

  - Logging and Audit Trail

    Implement detailed logging of report generation activities, including the start and end time of each report generation process, the user or system responsible for the request, and any relevant information about the report being generated.

  - Persistence

    Ideally, we want to save the generated reports for archival purposes and also track report failures; this way, we can tie report generation to the users that triggered them and track different versions of the report for audit purposes. This direction also allows us to store details of transactions before actually acting on them, which means we can do more things like queuing the requests for a later time.

  - Idempotence

    When a report generation request comes in, check the source table "time-reports" to see the last time it was updated, and compare that to the last time the report was generated. If anything has changed, if any changes have been made, generate a new report and clear out any in-progress/queued reports.

  - Implement an async background job for processing the payroll report as well

    Depending on the amount of data available, we wouldn't want to handle this synchronously; it would be better to notify the user that we've received the request and then respond with the data when available.

- Proper job notification so users know if there are any hiccups
- Implement a more scalable database like Postgres

## Compromises made due to the time crunch ()

- Testing

  - We need to Extend tests to cover more edge cases, guard clauses, workers and services as the requirements listed are the only test cases covered

- Persistence structure

  - A better representation of the relationships between the models would have been ideal i.e have an Employee_pay_period join table to normalize the database structure even more and also a table to store and track generated payroll reports

  - Chose to go with a lightweight structure for managing uploads, using the time-reports model as a true entry point to conserve time and make processing more straightforward.

- File processing status/failure management

  - Handling this in the controller for now, ideally we move this to the worker, have a "status" field on the model and methods to track the progress while the file is being processed for better error handling and possible FE display.

  - Did not implement Proper job queue management, Jop processing retries, or a notifications service.

  Design decision

  - Did not add any additional database indexes as modern database systems automatically add an index on the foreign key column.
