## README

# Running the application:

- run `bundle install`
- run `rake db: setup`
- run `rails s`
- run `bundle exec sidekiq` (leave running)
- run `redis-server` (leave running)

# Tests

- Test endpoints in postman
- run `bundle exec rspec spec`

# Persistence Structure (without autogenerated fields):

- Time_report

  - report_id: unique identifier for each file
  - employee_id(FK): to identify users before storing timesheet data (enables future enhancement for pulling all timesheets for a specific employee)
  - hours_worked: to store time worked in a period for each employee
  - job_group(FK): to store the employee's Job category
  - pay_period(FK): early optimization to store pay period for hours worked
  - Date: to store the date on which the employee worked

- Employee

  - employee_id: to uniquely store users in the system
  - job_group_id(FK): to store the employee's Job category

- Pay_periods

  - start_date: the start of a pay period
  - end_date: the end of a pay period

- Job_group

  - category: to store the job class, i.e., "A/B."
  - wage: to store the job pay i.e., "20"

# Requirements:

[ x ] Uploading a time report

```
Endpoint: http://localhost:3000/time_reports [POST]
payload:{
  "file_path": /path/to/file-id.csv
}

Successful Response: { "message": "File submitted successfully"}
Duplicate file upload error response: {error: "File has been processed before"}
Missing Parameter error response: {error: "File not included"}
```

[ x ] Retrieving a payroll report

```
Endpoint: http://localhost:3000/employee_reports [GET]

*Sample* Response: {
  "payrollReport": {
    "employeeReports": [{
      "employeeId": 1,
      "payPeriod": {
        "startDate": "2023-11-01",
        "endDate": "2023-11-15"
      },
      "amountPaid": "$140.00."
    }, {
      "employeeId": 1,
      "payPeriod": {
        "startDate": "2023-11-16",
        "endDate": "2023-11-30"
      },
      "amount paid": "$220.00."
    }, {
      "employeeId": 3,
      "payPeriod": {
        "startDate": "2023-12-01",
        "endDate": "2023-12-15"
      },
      "amountPaid": "$460.00."
    },  {
      "employeeId": 4,
      "payPeriod": {
        "startDate": "2023-12-01",
        "endDate": "2023-12-15"
      },
      "amountPaid": "$150.00."
    }, {
      "employeeId": 4,
      "payPeriod": {
        "startDate": "2023-12-16",
        "endDate": "2023-12-31"
      },
      "amountPaid": "$450.00."
    }]
  }
}
Successful: 200 OK
Unsuccessful response: { error: 'Failed to generate report' }
```

## Improvements to make this app production ready

- File storage and archival - Cloud storage

  Ideally, we should save raw files to S3 for a more robust, secure, and cost-effective solution for storing and managing data at scale. We want to keep customer provided file-data even after it has been processed.

- Improve security around the payroll API.

  No security features were implemented due to time constraints. Still, ideally, we should restrict access to privileged employee data, and only those with the correct permissions should be able to generate a payroll report.

- Ensure that report generation is better tracked, idempotent, and scalable:

  - Logging and Audit Trail

    Implement detailed logging of report generation activities, including each report generation process's start and end time, the user or system responsible for the request, and any relevant information about the generated report.

  - Persistence

    Ideally, we want to save the generated reports for archival purposes and also track report failures; this way, we can tie report generation to the users that triggered them and track different versions of the report for audit purposes. This direction also allows us to store details of transactions before actually acting on them, which means we can do more things like queuing the requests for a later time.

  - Idempotence

    When a report generation request comes in, check the source table "time-reports" to see the last time it was updated and compare it to the last time it was generated. If anything has changed, if any changes have been made, develop a new report and clear out any in-progress/queued reports.

  - Implement an async background job for processing the payroll report as well

    Depending on the amount of data available, we would want to avoid handling this synchronously; it would be better to notify the user that we've received the request and then respond with the data when available.

- Proper job notification so users know if there are any hiccups
- Implement a more scalable database like Postgres

## Compromises made due to the time crunch

- Testing

  - We need to Extend tests to cover more edge cases, guard clauses, workers, and services, as the requirements listed are the only test cases covered

- Persistence structure

  - A better representation of the relationships between the models would have been ideal, i.e have an Employee_pay_period join table to normalize the database structure even more and also a table to store and track generated payroll reports

  - Chose to go with a lightweight structure for managing uploads, using the time-reports model as a proper entry point to conserve time and make processing more straightforward.

- File processing status/failure management

  - Handling this in the controller for now; ideally, we move this to the worker and have a "status" field on the model and methods to track the progress while the file is being processed for better error handling and possible FE display.

  - Did not implement Proper job queue management, Jop processing retries, or a notifications service.

  Design decision

  - Did not add any additional database indexes, as modern database systems automatically add an index on the foreign key column.
